cmake_minimum_required(VERSION 3.5)
project(rclada_common)

set(${PROJECT_NAME}_MAJOR_VERSION 0)
set(${PROJECT_NAME}_MINOR_VERSION 1)
set(${PROJECT_NAME}_PATCH_VERSION 0)
set(${PROJECT_NAME}_VERSION
  ${${PROJECT_NAME}_MAJOR_VERSION}.${${PROJECT_NAME}_MINOR_VERSION}.${${PROJECT_NAME}_PATCH_VERSION})
set(PROJECT_VERSION ${${PROJECT_NAME}_VERSION})

message(" ")
message("${PROJECT_NAME} version ${PROJECT_VERSION}")

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

if(BUILD_TESTING)
  # Silence a warning (?)
endif()

# Detect builder and compiler

find_program(GPRBUILD gprbuild)
if (NOT GPRBUILD)
  message(SEND_ERROR "gprbuild must be available in PATH")
endif()

find_program(GNAT gnat)
if (NOT GNAT)
  message(SEND_ERROR "gnat must be available in PATH")
endif()

# Prepare common paths

set(ADA_BUILD_DIR ${PROJECT_BINARY_DIR})

set(ADA_GPR_DIR ${CMAKE_INSTALL_PREFIX}/share/gpr)
# Here we deploy projects that have manual sources
# Even if they include a "gen" folder autogenerated
# These have to ve developed in GPS using the real source folder
set(ADA_GPRIMPORT_DIR ${CMAKE_INSTALL_PREFIX}/share/gprimport)
# Here we deploy imported external libraries
# These projects can't be edited, but must be used while developing
# To avoid duplication of the manual/installed projects, we need to separate like this.
set(ADA_RESOURCE_DIR ${PROJECT_SOURCE_DIR}/resources)

# Include macros for Ada targets

include(cmake/ada_project.cmake)

# Generate some common C headers used by rosidl, rclada...

ada_generate_binding(
        ada_specs_common
        ${PROJECT_SOURCE_DIR}/gpr_c_builtins
        ""
        /usr/include/${CMAKE_LIBRARY_ARCHITECTURE}/bits/stdint-intn.h
        /usr/include/${CMAKE_LIBRARY_ARCHITECTURE}/bits/stdint-uintn.h
        /usr/include/${CMAKE_LIBRARY_ARCHITECTURE}/bits/types.h)

# Make us findable:

install(FILES cmake/ada_project.cmake
        DESTINATION share/${PROJECT_NAME}/cmake)
ada_export_package()

#get_cmake_property(_variableNames VARIABLES)
#list (SORT _variableNames)
#foreach (_variableName ${_variableNames})
#  message(STATUS "${_variableName}=${${_variableName}}")
#endforeach()